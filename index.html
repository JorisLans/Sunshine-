<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zonlicht Simulator - Gecorrigeerde Logica</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; margin: 0; padding: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        #map { flex: 1; width: 100%; z-index: 1; }
        .controls { 
            background: white; padding: 20px; box-shadow: 0 -4px 15px rgba(0,0,0,0.2); 
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px; z-index: 10; 
        }
        .control-group { display: flex; flex-direction: column; gap: 10px; }
        .time-header { display: flex; justify-content: space-between; align-items: center; }
        label { font-weight: bold; font-size: 14px; color: #333; }
        input[type="range"] { width: 100%; cursor: pointer; }
        .buttons { display: flex; gap: 8px; }
        button { flex: 1; padding: 10px; border: none; background: #4A90E2; color: white; border-radius: 6px; cursor: pointer; font-size: 13px; }
        #playBtn { flex: 0 0 100px; background: #2ecc71; font-weight: bold; }
        #playBtn.playing { background: #e74c3c; }
        .options-box { display: flex; flex-direction: column; gap: 8px; background: #f8f9fa; padding: 12px; border-radius: 8px; border: 1px solid #e1e4e8; }
        .checkbox-item { display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 13px; }
        .info { grid-column: span 2; font-size: 12px; color: #555; text-align: center; border-top: 1px solid #eee; padding-top: 10px; }
    </style>
</head>
<body>

    <div id="map"></div>

    <div class="controls">
        <div class="control-group">
            <div class="time-header">
                <label>Tijd: <span id="timeVal">12:00</span></label>
                <button id="playBtn" onclick="togglePlay()">▶ Play</button>
            </div>
            <input type="range" id="timeSlider" min="0" max="1439" value="720">

            <label>Datum:</label>
            <input type="date" id="datePicker">
            
            <div class="buttons">
                <button onclick="setSeason('zomer')">Zomer</button>
                <button onclick="setSeason('winter')">Winter</button>
                <button onclick="setSeason('nu')">Nu</button>
            </div>
        </div>

        <div class="control-group">
            <label>Oriëntatie Terras: <span id="rotationVal">180</span>°</label>
            <input type="range" id="rotationSlider" min="0" max="360" value="180">
            
            <div class="options-box">
                <label class="checkbox-item">
                    <input type="checkbox" id="roofToggle" checked onchange="updateSimulation()"> 
                    Terras is overdekt (verdiep erboven)
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" id="wallsToggle" checked onchange="updateSimulation()"> 
                    Zijmuren aanwezig (Loggia)
                </label>
            </div>
        </div>

        <div class="info" id="sunInfo">De blauwe lijn is het raam, het grijze vlak is het terras.</div>
    </div>

    <script>
        let lat = 51.0289, lng = 3.0142, currentDate = new Date(), roomRotation = 180;
        const earthRadius = 6378137;

        const timeSlider = document.getElementById('timeSlider');
        const datePicker = document.getElementById('datePicker');
        const rotationSlider = document.getElementById('rotationSlider');
        const roofToggle = document.getElementById('roofToggle');
        const wallsToggle = document.getElementById('wallsToggle');
        datePicker.valueAsDate = currentDate;

        const map = L.map('map').setView([lat, lng], 20);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 22 }).addTo(map);

        let simulationLayer = L.featureGroup().addTo(map);
        let marker = L.marker([lat, lng], {draggable: true}).addTo(map);

        function onLocationChange(e) {
            const pos = e.latlng || e.target.getLatLng();
            lat = pos.lat; lng = pos.lng;
            marker.setLatLng([lat, lng]);
            updateSimulation();
        }

        map.on('click', onLocationChange);
        marker.on('drag', onLocationChange);

        timeSlider.oninput = function() {
            currentDate.setHours(Math.floor(this.value / 60), this.value % 60);
            document.getElementById('timeVal').textContent = currentDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            updateSimulation();
        };

        rotationSlider.oninput = function() {
            roomRotation = parseInt(this.value);
            document.getElementById('rotationVal').textContent = roomRotation;
            updateSimulation();
        };

        function getPoint(x, y) {
            let rad = roomRotation * Math.PI / 180;
            let rx = x * Math.cos(rad) + y * Math.sin(rad);
            let ry = -x * Math.sin(rad) + y * Math.cos(rad);
            let dLat = (ry / earthRadius) * (180 / Math.PI);
            let dLng = (rx / (earthRadius * Math.cos(lat * Math.PI / 180))) * (180 / Math.PI);
            return [lat + dLat, lng + dLng];
        }

        function updateSimulation() {
            let sunPos = SunCalc.getPosition(currentDate, lat, lng);
            let azimuthDeg = (sunPos.azimuth * 180 / Math.PI) + 180;
            let altitudeRad = sunPos.altitude;
            let altitudeDeg = altitudeRad * 180 / Math.PI;

            document.getElementById('sunInfo').innerHTML = `Zon: ${azimuthDeg.toFixed(1)}° | Hoogte: ${altitudeDeg.toFixed(1)}°`;

            simulationLayer.clearLayers();

            let s = 5;      // Kamer half-breedte
            let w = 2.5;    // Raam half-breedte
            let tD = 4;     // Terras diepte
            let h = 2.7;    // Plafondhoogte

            // 1. Basis: Kamer en Terras vloer
            L.polygon([getPoint(-s, s), getPoint(s, s), getPoint(s, -s), getPoint(-s, -s)], {
                color: '#2c3e50', weight: 2, fillColor: '#fff', fillOpacity: 0.8
            }).addTo(simulationLayer);
            
            L.polygon([getPoint(-s, s), getPoint(s, s), getPoint(s, s+tD), getPoint(-s, s+tD)], {
                color: '#7f8c8d', weight: 1, fillColor: '#bdc3c7', fillOpacity: 0.6
            }).addTo(simulationLayer);

            // 2. Muren en Ramen
            L.polyline([getPoint(-w, s), getPoint(w, s)], { color: '#3498db', weight: 6 }).addTo(simulationLayer);
            if (wallsToggle.checked) {
                L.polyline([getPoint(-s, s), getPoint(-s, s+tD)], { color: '#2c3e50', weight: 4 }).addTo(simulationLayer);
                L.polyline([getPoint(s, s), getPoint(s, s+tD)], { color: '#2c3e50', weight: 4 }).addTo(simulationLayer);
            }

            // 3. De Licht-Logica
            if (altitudeDeg > 0) {
                let relAzimuth = azimuthDeg - roomRotation;
                let rad = relAzimuth * Math.PI / 180;
                let vx = -Math.sin(rad);
                let vy = Math.cos(rad);

                if (vy > -0.5) { // Zon komt van de voorkant
                    // Schaduw van de dakrand valt naar binnen
                    // De dakrand bevindt zich op y = s + tD
                    let shadowL = h / Math.tan(altitudeRad);
                    let shadowBoundaryY = (s + tD) - shadowL;

                    // Waar begint en eindigt het licht op de y-as?
                    let lightStart = Math.max(s - 10, shadowBoundaryY); // Licht kan kamer in gaan
                    let lightEnd = s + tD; // Licht stopt aan de rand van het terras

                    if (lightEnd > lightStart) {
                        // Bereken zijwaartse schaduw van muren (vx)
                        let xL = -s, xR = s;
                        if (wallsToggle.checked) {
                            // De schaduw van een muur op afstand d is d * tan(relAzimuth)
                            // Maar makkelijker: gebruik de vx/vy verhouding
                            let wallShadowOffset = shadowL * vx;
                            if (vx > 0) xL = Math.max(-s, -s + wallShadowOffset);
                            if (vx < 0) xR = Math.min(s, s + wallShadowOffset);
                        }

                        // Teken Licht op Terras
                        let terraceLightYStart = Math.max(s, lightStart);
                        if (terraceLightYStart < lightEnd) {
                            L.polygon([
                                getPoint(xL, terraceLightYStart), getPoint(xR, terraceLightYStart),
                                getPoint(xR, lightEnd), getPoint(xL, lightEnd)
                            ], { stroke: false, fillColor: '#f1c40f', fillOpacity: 0.4 }).addTo(simulationLayer);
                        }

                        // Teken Licht in Kamer (door het raam)
                        if (lightStart < s) {
                            let roomLightEnd = s;
                            let roomLightStart = lightStart;
                            
                            // Beperk breedte tot raambreedte
                            let rxL = Math.max(-w, xL);
                            let rxR = Math.min(w, xR);

                            if (rxR > rxL) {
                                L.polygon([
                                    getPoint(rxL, roomLightStart), getPoint(rxR, roomLightStart),
                                    getPoint(rxR, roomLightEnd), getPoint(rxL, roomLightEnd)
                                ], { stroke: false, fillColor: '#f1c40f', fillOpacity: 0.6 }).addTo(simulationLayer);
                            }
                        }
                    }
                }
            }
        }

        // --- Rest van de functies (Play/Seizoenen) blijven hetzelfde ---
        let isPlaying = false, animationInterval;
        function togglePlay() {
            isPlaying = !isPlaying;
            if (isPlaying) {
                playBtn.innerHTML = '⏸ Pauze'; playBtn.classList.add('playing');
                animationInterval = setInterval(() => {
                    let v = (parseInt(timeSlider.value) + 5) % 1440;
                    timeSlider.value = v; timeSlider.oninput();
                }, 50);
            } else {
                playBtn.innerHTML = '▶ Play'; playBtn.classList.remove('playing');
                clearInterval(animationInterval);
            }
        }

        function setSeason(s) {
            let y = 2026;
            if(s === 'zomer') currentDate = new Date(y, 5, 21, 13, 0);
            if(s === 'winter') currentDate = new Date(y, 11, 21, 12, 0);
            if(s === 'nu') currentDate = new Date();
            datePicker.valueAsDate = currentDate;
            timeSlider.value = currentDate.getHours() * 60 + currentDate.getMinutes();
            timeSlider.oninput();
        }

        updateSimulation();
    </script>
</body>
</html>
